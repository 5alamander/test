// Generated by CoffeeScript 1.9.2
(function() {
  var DialogLayer, Kernel, atom, countTab, parseLine, parseOneLine, parseStp, root,
    slice = [].slice;

  String.prototype.Trim = function() {
    return this.replace(/(^\s*)|(\s*$)/g, "");
  };

  countTab = function(str) {
    var count, i, k, ref;
    count = 0;
    for (i = k = 0, ref = str.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
      if (str[i] === '\t') {
        count++;
      } else {
        break;
      }
    }
    return count;
  };

  parseOneLine = function(line) {
    var n, result, t;
    line.replace(/ï¼š/g, ':');
    n = line.indexOf(':');
    result = [];
    if (n > -1) {
      if (n !== 0) {
        result.push(line.slice(0, n));
      }
      result.push(':');
      result.push(line.slice(n + 1));
    } else {
      result = line.Trim().split(' ');
    }
    return (function() {
      var k, len, results;
      results = [];
      for (k = 0, len = result.length; k < len; k++) {
        t = result[k];
        if (t !== '') {
          results.push(t);
        }
      }
      return results;
    })();
  };

  parseLine = function(src) {
    var cmd, createCmd, lines, n, ref, t;
    lines = src.replace(/\r\n/g, '\n').split('\n');
    lines = (function() {
      var k, len, results;
      results = [];
      for (k = 0, len = lines.length; k < len; k++) {
        t = lines[k];
        if (t.Trim() !== '') {
          results.push(t);
        }
      }
      return results;
    })();
    createCmd = function(n, tab) {
      var cmd, ctab, l, lc, ref, tc;
      cmd = [];
      while (n < lines.length) {
        l = lines[n];
        ctab = countTab(l);
        if (ctab === tab) {
          cmd.push(parseOneLine(l));
          n++;
        } else if (ctab > tab) {
          lc = cmd.pop();
          ref = createCmd(n, ctab), n = ref[0], tc = ref[1];
          cmd.push(slice.call(lc).concat(slice.call(tc)));
        } else {
          return [n, cmd];
        }
      }
      return [n, cmd];
    };
    ref = createCmd(0, 0), n = ref[0], cmd = ref[1];
    return cmd;
  };

  atom = function(s) {
    s = s.Trim();
    if (s === '(') {
      return '[';
    }
    if (s === ')') {
      return '],';
    }
    if (s === ',') {
      return '';
    }
    return "\'" + s + "\',";
  };


  /**
   * parseStp as a tree
   * use ", ( ) \s " to split
   * @param  {string} src the source text
   * @return {array}     the tree
   */

  parseStp = function(src) {
    var error, s, t, tokens;
    tokens = src.replace(/\(/g, ' ( ').replace(/\)/g, ' ) ').replace(/,/g, ' , ').replace(/\t/g, ' ').split(' ');
    t = ((function() {
      var k, len, results;
      results = [];
      for (k = 0, len = tokens.length; k < len; k++) {
        s = tokens[k];
        if (s.Trim() !== '') {
          results.push(atom(s));
        }
      }
      return results;
    })()).join(' ');
    t = t.substring(0, t.length - 1);
    try {
      return eval(t);
    } catch (_error) {
      error = _error;
      console.log(error);
      console.log(src);
      return error;
    }
  };


  /**
   * aim = {
   *  	showChoice: (arg) ->
   *  	check: (arg)->
   *  	flag: (arg)->  	
   * }
   */

  Kernel = (function() {

    /**
    	 * create a kernel with source code
    	 * @param  {string} str source code
        * @param  {layer} target
     */
    function Kernel(str, evn) {
      this.evn = evn;
      this.init(str);
    }

    Kernel.prototype.init = function(str) {
      this.jscode = {};
      this.cmds = [parseLine(str)];
      return this.waitInput = false;
    };


    /**
    	 * run next command
    	 * skip, string
    	 * fix, [[]] to []
    	 * @param  {number}   n [choice]
    	 * @return {runMessage}
    	 * 'error', 'end', 'waitChoice', 'noFunction'
     */

    Kernel.prototype.next = function(n) {
      var cond, exp, temp;
      if (this.waitInput && (n == null)) {
        console.log('input error: wait input');
        return 'waitChoice';
      }
      exp = this.cmds.pop();
      if (exp == null) {
        console.log('script end');
        return 'end';
      }
      if (exp instanceof Array === false) {
        console.log('skip: ' + exp);
        return this.next();
      } else if (exp.length === 1) {
        console.log('fix: ' + exp[0]);
        this.cmds.push(exp[0]);
        return this.next();
      } else if (exp[0] instanceof Array) {
        this.cmds = this.cmds.concat(exp.reverse());
        return this.next();
      } else if (typeof exp[0] === 'string') {
        console.log('exp is : ' + exp[0]);
        switch (exp[0]) {
          case 'sequence':
            if (exp.length < 2) {
              console.log('error: sequence is not enough');
              return 'argumentError';
            }
            exp.reverse();
            this.cmds = this.cmds.concat(exp.slice(0, -1));
            return this.next();
          case 'choice':
            if (exp.length < 3) {
              console.log('error: choice is not enough');
              return 'argumentError';
            }
            if (n == null) {
              this.evn.showChoice(exp.slice(1));
              console.log('choice wait command');
              this.cmds.push(exp);
              this.waitInput = true;
              return 'waitChoice';
            } else {
              console.log('chooce ' + n);
              if (n < 1 || n > exp.length) {
                console.log('error: choice is out of bound');
                return 'error';
              }
              this.waitInput = false;
              exp[n][0] = 'sequence';
              this.cmds.push(exp[n]);
              return this.next();
            }
            break;
          case 'if':
            if (exp.length < 3) {
              console.log('error: condition is not enough');
              return 'argumentError';
            }
            cond = this.evn.check(exp[1]);
            if (cond) {
              this.cmds.push(exp[2]);
            } else if (exp.length === 4) {
              this.cmds.push(exp[3]);
            }
            return this.next();
          case 'goto':
            console.log('to find tag: ' + exp[1]);
            temp = this.findTag(exp[1]);
            if (temp >= 0) {
              this.cmds = this.cmds.slice(0, temp);
              return this.next();
            }
            return 'goto';
          default:
            if (exp.indexOf(':') !== -1) {
              this.evn._showText('character:' + exp);
              return 'character';
            } else {
              console.log('no function');
              this.evn._showText('no function: ' + exp);
              return 'noFunction';
            }
        }
      }
    };

    Kernel.prototype.findTag = function(str) {
      var i, k, ref;
      for (i = k = ref = this.cmds.length - 1; ref <= 0 ? k <= 0 : k >= 0; i = ref <= 0 ? ++k : --k) {
        if (this.cmds[i][0] === 'tag' && this.cmds[i][1] === str) {
          return i;
        }
      }
      return -1;
    };

    return Kernel;

  })();

  DialogLayer = cc.Layer.extend({
    _loadRes: function() {
      cc.spriteFrameCache.addSpriteFrames(res.res_plist);
      return cc.textureCache.addImage(res.res_png);
    },
    _loadStp: function(name) {
      return cc.loader._loadTxtSync('src/' + name);
    },
    _createUI: function() {
      var size, t, that;
      that = this;
      size = cc.winSize;
      this.ui = {};
      t = this.ui.backGround = new cc.Sprite('res/background/bg.jpg');
      t.attr({
        x: size.width / 2,
        y: size.height / 2,
        scale: 1.2
      });
      this.addChild(t, -10);
      t = this.ui.backMask = new cc.Sprite(res.black_back);
      t.attr({
        x: size.width / 2,
        y: size.height / 2,
        scale: 8
      });
      this.addChild(t, -1);
      t.setVisible(false);
      t = this.ui.dialogBack = new ccui.ImageView(res.dialog_back);
      t.setScale9Enabled(true);
      t.setContentSize(cc.size(size.width - 40, size.height * 0.3));
      t.attr({
        x: size.width / 2,
        y: t.height / 2 + 10
      });
      this.addChild(t, 10);
      t = this.ui.dialogTxt = new ccui.Text("", "Arial", 28);
      t.ignoreContentAdaptWithSize(false);
      t.setContentSize(this.ui.dialogBack.width - 40, this.ui.dialogBack.height - 30);
      t.attr({
        x: this.ui.dialogBack.width / 2,
        y: this.ui.dialogBack.height / 2
      });
      t.setTextColor(cc.color(0, 0, 0, 255));
      t.setTextHorizontalAlignment(cc.TEXT_ALIGNMENT_LEFT);
      this.ui.dialogBack.addChild(t, 10);
      t = this.ui.choiceBack = new cc.Sprite(res.black_back);
      t.attr({
        x: size.width / 2,
        y: size.height / 2,
        scale: 8
      });
      this.addChild(t, 20);
      t.setOpacity(0);
      t = this.ui.choicePane = new cc.Node();
      this.addChild(t, 21);
      return t.setVisible(false);
    },
    _showChoice: function(c) {
      var choiceAction, i, k, layer, n, offsetY, ref, results, size, t;
      if (!(c instanceof Array)) {
        throw 'showChoice error';
      }
      layer = this;
      size = cc.winSize;
      this.evn.isWaitingChoice = true;
      this.ui.choiceBack.runAction(cc.fadeIn(0.6));
      this.ui.choicePane.setVisible(true);
      n = c.length;
      offsetY = (n - 1) / 2;
      choiceAction = function() {
        var choice, j, k, len, ref, results, tc;
        if (this.opacity < 60) {
          return;
        }
        if ((this._waitDelete != null) === true) {
          return;
        }
        choice = this;
        layer.scheduleOnce(function() {
          return layer._hideChoice();
        }, 1.5);
        layer.scheduleOnce(function() {
          layer.k.next(choice.choiceIndex);
          return layer.evn.isWaitingChoice = false;
        }, 2.5);
        this.runAction(cc.sequence(cc.spawn(cc.scaleTo(0.8, 1.6).easing(cc.easeSineInOut()), cc.moveTo(0.8, size.width / 2, size.height / 2)), cc.blink(0.6, 3).easing(cc.easeSineIn())));
        j = 0;
        ref = layer.ui.choicePane._children;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          tc = ref[k];
          if (!(tc !== this)) {
            continue;
          }
          tc._waitDelete = true;
          results.push(tc.runAction(cc.sequence(cc.delayTime(j++ * 0.4), cc.spawn(cc.moveBy(1, 400, 0).easing(cc.easeSineInOut()), cc.fadeOut(1)))));
        }
        return results;
      };
      results = [];
      for (i = k = 0, ref = n; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        t = new cc.LabelTTF(c[i], "Arial", 36);
        t.choiceIndex = i + 1;
        t.attr({
          x: size.width / 2,
          y: size.height / 2 - 36 * 1.8 * (i - offsetY),
          opacity: 0
        });
        this.ui.choicePane.addChild(t, 10);
        t.runAction(cc.sequence(cc.delayTime(0.25 * (i + 1)), cc.fadeIn(0.6)));
        results.push(gs(t).click(choiceAction));
      }
      return results;
    },
    _hideChoice: function() {
      this.ui.choiceBack.runAction(cc.fadeOut(0.6));
      this.ui.choicePane.setVisible(false);
      return this.ui.choicePane.removeAllChildren(true);
    },
    _showText: function(text) {
      var count, that;
      if (text == null) {
        text = '';
      }
      that = this;
      this.evn.isShowingText = true;
      this.evn.currentText = text;
      count = 0;
      this._showTextSchedule = function() {
        count++;
        that.ui.dialogTxt.setString(text.slice(0, +count + 1 || 9e9));
        if (count > text.length) {
          that.unschedule(that._showTextSchedule);
          return that.evn.isShowingText = false;
        }
      };
      return this.schedule(that._showTextSchedule, 0.15, cc.REPEAT_FOREVER, 0.1);
    },
    _cutTextShow: function() {
      var that;
      that = this;
      that.unschedule(that._showTextSchedule);
      that.ui.dialogTxt.setString(that.evn.currentText);
      return that.evn.isShowingText = false;
    },
    evn: {
      currentText: '',
      isShowingText: false,
      isWaitingChoice: false
    },
    config: {
      showTextSpeed: 0.15
    },
    state: {
      storyProgress: 1
    },
    showChoice: function(arg) {
      var c, t;
      c = (function() {
        var k, len, results;
        results = [];
        for (k = 0, len = arg.length; k < len; k++) {
          t = arg[k];
          results.push(t[0]);
        }
        return results;
      })();
      return this._showChoice(c);
    },
    check: function(arg) {
      this._showText('check:' + arg);
      console.log('call check : ' + arg);
      return true;
    },
    flag: function(arg) {
      this._showText('flag:' + arg);
      console.log('call check : ' + arg);
      return true;
    },
    ctor: function() {
      var c1, c2, countn, data, size, that;
      that = this;
      this._super();
      this._loadRes();
      this._createUI();
      size = cc.winSize;
      c1 = new cc.Sprite('res/character/c_a.png');
      c1.attr({
        x: 250,
        y: 250,
        scale: 1.5
      });
      c2 = new cc.Sprite('res/character/c_b.png');
      c2.attr({
        x: size.width - 250,
        y: 250,
        scale: 1.5
      });
      this.addChild(c1, 1);
      this.addChild(c2, 2);
      data = this._loadStp('temp.strip');
      if (this.k != null) {
        throw 'k is being used';
      }
      this.k = new Kernel(data, this);
      countn = 0;
      return gs(this).click(function() {
        if (that.evn.isShowingText) {
          return that._cutTextShow();
        } else if (that.evn.isWaitingChoice) {
          return 'wait choice';
        } else {
          that.k.next();
          return console.log("dialogLayer.coffee click (#73): " + 'show next');
        }
      });
    }
  });

  root = typeof exports !== "undefined" && exports !== null ? exports : window;

  root.DialogLayer = DialogLayer;

}).call(this);

//# sourceMappingURL=dialogLayer.js.map
