// Generated by CoffeeScript 1.9.2

/**
 * @property 'fullName',
		get: -> 
		set: (name) -> 
 * @param  {string} prop [name of property]
 * @param  {[type]} desc [description]
 * @return {[type]}      [description]
 */

(function() {
  var Buff, BuffHandler, CardMode, ElementRate, ElementTable, EventManager, Grid, Player, Table, Trigger, a, b, checkEM, checkEMBuff, i, j, m, random, remove, root, skill, t, table,
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Function.prototype.property = function(prop, desc) {
    return Object.defineProperty(this.prototype, prop, desc);
  };

  Array.prototype["delete"] = function(o) {
    var n;
    n = this.indexOf(o);
    if (n === -1) {
      return null;
    }
    this.splice(n, 1);
    this["delete"](o);
    return this;
  };

  remove = function(list, n) {
    var t;
    t = list[n];
    list.splice(n, 1);
    return t;
  };

  random = function(n) {
    return Math.floor(Math.random() * n);
  };

  ElementTable = {
    '普通': {
      '岩': 0.75,
      '鬼': 0,
      '钢': 0.75
    },
    '火': {
      '火': 0.75,
      '水': 0.75,
      '草': 1.5,
      '冰': 1.5,
      '虫': 1.5,
      '岩': 0.75,
      '龙': 0.75,
      '钢': 1.5
    },
    '水': {
      '火': 1.5,
      '水': 0.75,
      '草': 0.75,
      '地面': 1.5,
      '岩': 1.5,
      '龙': 0.75
    },
    '草': {
      '火': 0.75,
      '水': 1.5,
      '草': 0.75,
      '毒': 0.75,
      '地面': 1.5,
      '飞行': 0.75,
      '虫': 0.75,
      '岩': 1.5,
      '龙': 0.75,
      '钢': 0.75
    },
    '电': {
      '水': 1.5,
      '草': 0.75,
      '电': 0.75,
      '地面': 0,
      '飞行': 1.5,
      '龙': 0.75
    },
    '冰': {
      '火': 0.75,
      '水': 0.75,
      '草': 1.5,
      '冰': 0.75,
      '地面': 1.5,
      '飞行': 1.5,
      '龙': 1.5,
      '钢': 0.75
    },
    '格斗': {
      '普通': 1.5,
      '冰': 1.5,
      '毒': 0.75,
      '飞行': 0.75,
      '超能': 0.75,
      '虫': 0.75,
      '岩': 1.5,
      '鬼': 0,
      '恶': 1.5,
      '钢': 1.5,
      '妖': 0.75
    },
    '毒': {
      '草': 1.5,
      '毒': 0.75,
      '地面': 0.75,
      '岩': 0.75,
      '鬼': 0.75,
      '钢': 0,
      '妖': 1.5
    },
    '地面': {
      '火': 1.5,
      '草': 0.75,
      '电': 1.5,
      '毒': 1.5,
      '飞行': 0,
      '虫': 0.75,
      '岩': 1.5,
      '钢': 1.5
    },
    '飞行': {
      '草': 1.5,
      '电': 0.75,
      '格斗': 1.5,
      '虫': 1.5,
      '岩': 0.75,
      '钢': 0.75
    },
    '超能': {
      '格斗': 1.5,
      '毒': 1.5,
      '超能': 0.75,
      '恶': 0,
      '钢': 0.75
    },
    '虫': {
      '火': 0.75,
      '草': 1.5,
      '格斗': 0.75,
      '毒': 0.75,
      '飞行': 0.75,
      '超能': 0.75,
      '鬼': 0.75,
      '恶': 1.5,
      '钢': 0.75,
      '妖': 0.75
    },
    '岩': {
      '火': 1.5,
      '冰': 1.5,
      '格斗': 0.75,
      '地面': 0.75,
      '飞行': 1.5,
      '虫': 1.5,
      '钢': 0.75
    },
    '鬼': {
      '普通': 0,
      '超能': 1.5,
      '鬼': 1.5,
      '恶': 0.75
    },
    '龙': {
      '龙': 1.5,
      '钢': 0.75,
      '妖': 0
    },
    '恶': {
      '格斗': 0.75,
      '超能': 1.5,
      '鬼': 1.5,
      '恶': 0.75,
      '妖': 0.75
    },
    '钢': {
      '火': 0.75,
      '水': 0.75,
      '电': 0.75,
      '冰': 1.5,
      '岩': 1.5,
      '钢': 0.75,
      '妖': 1.5
    },
    '妖': {
      '火': 0.75,
      '格斗': 1.5,
      '毒': 0.75,
      '龙': 1.5,
      '恶': 1.5,
      '钢': 0.75
    }
  };

  ElementRate = function(e1, e2) {
    var r;
    if (ElementTable[e1] == null) {
      throw 'ERROR: no such a element';
    }
    r = 1;
    if (ElementTable[e1][e2] != null) {
      r = ElementTable[e1][e2];
    }
    return r;
  };

  Trigger = (function() {
    Trigger.prototype.BEFOR = 0;

    Trigger.prototype.AFTER = 1;

    Trigger.prototype.AVOID = 2;

    function Trigger(name1, father1) {
      this.name = name1;
      this.father = father1 != null ? father1 : null;
      this.clear();
    }

    Trigger.prototype.clear = function() {
      this.bf = [];
      this.af = [];
      return this.av = [];
    };

    Trigger.prototype.listen = function(waitter, n) {
      if (n == null) {
        n = 0;
      }
      if (n === this.BEFOR) {
        this.bf.push(waitter);
      }
      if (n === this.AFTER) {
        this.af.push(waitter);
      }
      if (n === this.AVOID) {
        return this.av.push(waitter);
      }
    };

    Trigger.prototype.disListen = function(waitter) {
      this.bf["delete"](waitter);
      this.af["delete"](waitter);
      return this.av["delete"](waitter);
    };

    Trigger.prototype.setcb = function(cb1) {
      this.cb = cb1;
    };

    Trigger.prototype.cb = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return console.log(this.name + ' callback: ' + args);
    };


    /**
    	 * #{name}, #{name}After, #{name}Avoid
    	 * @param  {Array} args... all type
    	 * @return {boolean}  return true if succeed, else false
     */

    Trigger.prototype.broadcast = function(args) {
      var j, len, len1, len2, m, name1, name2, passFather, passThis, q, ref, ref1, ref2, ref3, w;
      console.log('broadcast: ' + this.name);
      passThis = true;
      passFather = true;
      ref = this.bf;
      for (j = 0, len = ref.length; j < len; j++) {
        w = ref[j];
        if (w.isSilence) {
          continue;
        }
        if (w[this.name].apply(w, args) === false) {
          passThis = false;
          break;
        }
      }
      if (passThis && (this.father != null)) {
        passFather = this.father.broadcast(args);
      }
      if (!passThis || !passFather) {
        console.log('broadcast: ' + this.name + 'Avoid');
        ref1 = this.av;
        for (m = 0, len1 = ref1.length; m < len1; m++) {
          w = ref1[m];
          if (typeof w[name1 = this.name + 'Avoid'] === "function") {
            w[name1].apply(w, args);
          }
        }
        return false;
      }
      (ref2 = this.cb).call.apply(ref2, [this].concat(slice.call(args)));
      console.log('broadcast: ' + this.name + 'After');
      ref3 = this.af;
      for (q = 0, len2 = ref3.length; q < len2; q++) {
        w = ref3[q];
        if (typeof w[name2 = this.name + 'After'] === "function") {
          w[name2].apply(w, args);
        }
      }
      return true;
    };

    return Trigger;

  })();


  /**
   * attribute is all triggers
   */

  EventManager = (function() {
    function EventManager() {
      var tree;
      tree = [['whenAttack', 'whenMagicAttack', 'whenPhysicAttack'], 'whenCall', 'whenRegain', ['whenChange', 'whenEvolute'], 'whenTurnStart', 'whenTurnEnd', ['whenAddBuff', 'whenAddBadBuff', 'whenAddGoodBuff']];
      this.init(tree);
    }

    EventManager.prototype.init = function(exp, father) {
      var createTree, that;
      if (father == null) {
        father = null;
      }
      that = this;
      createTree = function(exp, father) {
        var e, j, len, len1, m, ref, ref1, results, results1, t;
        if (exp instanceof Array) {
          if (exp[0] instanceof Array) {
            createTree(exp[0], father);
            ref = exp.slice(1);
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              e = ref[j];
              results.push(createTree(e, father));
            }
            return results;
          } else {
            t = that[exp[0]] = new Trigger(exp[0], father);
            ref1 = exp.slice(1);
            results1 = [];
            for (m = 0, len1 = ref1.length; m < len1; m++) {
              e = ref1[m];
              results1.push(createTree(e, t));
            }
            return results1;
          }
        } else {
          return that[exp] = new Trigger(exp, father);
        }
      };
      return createTree(exp, father);
    };

    EventManager.prototype.clear = function() {
      var k, results, v;
      results = [];
      for (k in this) {
        v = this[k];
        if (v instanceof Trigger) {
          results.push(v.clear());
        }
      }
      return results;
    };

    EventManager.prototype.setcbs = function(cbs) {
      var cb, key, ref, results;
      results = [];
      for (key in cbs) {
        cb = cbs[key];
        results.push((ref = this[key]) != null ? ref.setcb(cb) : void 0);
      }
      return results;
    };

    EventManager.prototype.listen = function(waitter, eventName) {
      var d, n, t;
      n = 0;
      t = eventName.indexOf('After');
      if (t > 0) {
        n = 1;
        eventName = eventName.slice(0, t);
      }
      d = eventName.indexOf('Avoid');
      if (d > 0) {
        n = 2;
        eventName = eventName.slice(0, d);
      }
      if (this[eventName] == null) {
        throw 'listen to a trigger not defined: ' + eventName;
      }
      return this[eventName].listen(waitter, n);
    };

    EventManager.prototype.disListen = function(waitter, eventName) {
      if (this[eventName] != null) {
        return this[eventName].disListen(waitter);
      }
    };

    EventManager.prototype.broadcast = function() {
      var args, eventName;
      eventName = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (this[eventName] == null) {
        throw 'broadcast a trigger not defined: ' + eventName;
      }
      return this[eventName].broadcast(args);
    };

    return EventManager;

  })();

  checkEM = function(e) {
    var k, ref, v;
    console.log('checkEM--------------------');
    for (k in e) {
      v = e[k];
      if (v instanceof Trigger) {
        console.log(e[k].name + ' -> ' + ((ref = e[k].father) != null ? ref.name : void 0));
      }
    }
    return console.log('checkEM end----------------');
  };

  checkEMBuff = function(e) {
    var k, temp, v;
    console.log('checkEMBuff----------------');
    for (k in e) {
      v = e[k];
      if (!(v instanceof Trigger)) {
        continue;
      }
      temp = e[k];
      console.log(k + ': ');
      console.log(temp.bf.concat(temp.af).concat(temp.av));
    }
    return console.log('checkEMBuff end------------');
  };

  Buff = (function() {
    Buff.prototype.isSilence = false;

    Buff.prototype.owner = null;

    Buff.prototype.lifeTime = 1;

    function Buff(initial) {
      var key, value;
      console.log('create a buff');
      this.turnCount = 0;
      this.tags = [];
      for (key in initial) {
        value = initial[key];
        if (key.indexOf('when') === 0) {
          this.tags.push(key);
        }
        this.decorateByST(key, value);
      }
    }

    Buff.prototype.turnUpdate = function(n) {
      this.lifeTime -= n;
      this.turnCount += n;
      if (!(this.lifeTime > 0)) {
        return;
      }
      if (this.isSilence !== false) {
        return;
      }
      return typeof this.onUpdate === "function" ? this.onUpdate(n) : void 0;
    };

    Buff.prototype.activate = function() {
      var j, len, ref, results, tag;
      ref = this.tags;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        tag = ref[j];
        results.push(this.table.em.listen(this, tag));
      }
      return results;
    };

    Buff.prototype.destroy = function() {
      var j, len, ref, results, tag;
      ref = this.tags;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        tag = ref[j];
        results.push(this.table.em.disListen(this, tag));
      }
      return results;
    };

    Buff.prototype.decorateByST = function(key, func) {
      return this[key] = function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        if (this.isSilence || (this.lifeTime <= 0)) {
          return;
        }
        return func.call.apply(func, [this].concat(slice.call(args)));
      };
    };

    return Buff;

  })();

  Buff.testBuff = function() {
    return new Buff({
      whenAttack: function() {
        return console.log('buff attack log');
      },
      whenAttackAfter: function() {
        return console.log('buff attack after log');
      }
    });
  };

  BuffHandler = (function() {
    function BuffHandler() {
      this.buffs = [];
    }

    BuffHandler.prototype.setPlayerAndTable = function(player1, table1) {
      this.player = player1;
      this.table = table1;
      return this;
    };

    BuffHandler.prototype.addBuff = function(buff) {
      buff.owner = this;
      buff.table = this.table;
      buff.activate();
      return this.buffs.push(buff);
    };

    BuffHandler.prototype.removeBuff = function(buff) {
      buff.destroy();
      buff.owner = null;
      buff.table = null;
      return this.buffs["delete"](buff);
    };

    return BuffHandler;

  })();

  CardMode = (function(superClass) {
    var createAttribute, that;

    extend(CardMode, superClass);

    CardMode.prototype.hp = 310;

    CardMode.prototype.maxHp = 310;

    CardMode.prototype._hpRate = 1;

    CardMode.prototype.hpExtra = 0;

    CardMode.prototype.x = 0;

    CardMode.prototype.y = 0;

    function CardMode(pd, pl) {
      this.pd = pd;
      this.pl = pl;
      CardMode.__super__.constructor.call(this);
      if (this.pd != null) {
        this.createData();
      }
      this.skills = [];
    }

    CardMode.prototype.createData = function() {
      this.id = this.pd.id;
      this.name = this.pd.name;
      this.hp = this.pd.hp;
      this.maxHp = this.pd.hp;
      this.atk = this.pd.atk;
      this.def = this.pd.def;
      this.satk = this.pd.satk;
      this.sdef = this.pd.sdef;
      return this.spd = this.pd.spd;
    };

    CardMode.prototype.hpChange = function(d) {
      if (d > 0) {
        this.hp += d;
        if (this.hp > this.maxHp) {
          this.hp = this.maxHp;
        }
      } else if (d < 0) {
        if (this.hpExtra > 0) {
          this.hpExtra += d;
          if (this.hpExtra < 0) {
            this.hpExtra = 0;
          }
        } else {
          this.hp += d;
        }
      }
      return this;
    };

    CardMode.prototype.turnUpdate = function(n) {
      var b, buff, j, len, ref;
      ref = this.buffs;
      for (j = 0, len = ref.length; j < len; j++) {
        buff = ref[j];
        buff.turnUpdate(n);
      }
      return this.buffs = (function() {
        var len1, m, ref1, results;
        ref1 = this.buffs;
        results = [];
        for (m = 0, len1 = ref1.length; m < len1; m++) {
          b = ref1[m];
          if (b.lifeTime > 0) {
            results.push(b);
          }
        }
        return results;
      }).call(this);
    };

    CardMode.prototype.act = function() {
      return this.table.cmds.push(['actStart', this]);
    };

    CardMode.prototype.isAlive = function() {
      if (this.hp > 0) {
        return true;
      } else {
        return false;
      }
    };

    that = CardMode;

    CardMode.property('hpRate', {
      set: function(v) {
        var d;
        d = v / this._hpRate;
        this.hp *= d;
        this.maxHp *= d;
        return this._hpRate = v;
      },
      get: function() {
        return this._hpRate;
      }
    });

    createAttribute = function(name, value) {
      var e, l, ln, n, r, v;
      if (value == null) {
        value = 100;
      }
      n = '_' + name;
      r = name + 'Rate';
      e = name + 'Extra';
      l = '_' + name + 'Level';
      v = name + 'Value';
      ln = name + 'Level';
      that.prototype[n] = value;
      that.prototype[r] = 1;
      that.prototype[e] = 0;
      that.prototype[l] = 0;
      that.property(ln, {
        set: function(v) {
          if (v > 6) {
            v = 6;
          }
          if (v < -6) {
            v = -6;
          }
          this[l] = v;
          return this;
        },
        get: function() {
          return this[l];
        }
      });
      that.property(v, {
        set: function(v) {
          return this;
        },
        get: function() {
          var t;
          t = this[ln];
          if (t > 0) {
            t = (4 + t) / 4;
          } else if (t < 0) {
            t = 4 / (4 - t);
          }
          return this[name] * t;
        }
      });
      return that.property(name, {
        set: function(v) {
          this[n] = (v - this[e]) / this[r];
          return this;
        },
        get: function() {
          return this[n] * this[r] + this[e];
        }
      });
    };

    createAttribute('atk');

    createAttribute('def');

    createAttribute('satk');

    createAttribute('sdef');

    createAttribute('spd');

    createAttribute('acc');

    return CardMode;

  })(BuffHandler);

  CardMode.testCard = function(id, name) {
    return new CardMode({
      id: id || -1,
      name: name || 'Unknown'
    });
  };

  Grid = (function() {
    Grid.prototype.pokemon = null;

    function Grid(row1, col1, player1, table1) {
      this.row = row1;
      this.col = col1;
      this.player = player1;
      this.table = table1;
      this.gridHandler = new BuffHandler();
      this.gridHandler.setPlayerAndTable(this.player, this.table);
    }

    Grid.prototype.setPokemon = function(pokemon) {
      this.pokemon = pokemon;
      this.pokemon.x = this.col;
      return this.pokemon.y = this.row;
    };

    Grid.prototype.removePokemon = function() {
      this.pokemon.x = -1;
      this.pokemon.y = -1;
      return this.pokemon = null;
    };

    return Grid;

  })();


  /**
   * name: string
   * flag: number (DEFENSER = 0, ATTACKER = 1)
   * field: array, grids in battle field
   * playerHandler: CardMode, to handle player buffs
   * list: array, all pokemons
   * handList: array, pokemon in hand
   * callList: array, pokemon in battle
   * table: Table, battle field
   */

  Player = (function() {
    Player.prototype.DEFENSER = 0;

    Player.prototype.ATTACKER = 1;

    function Player(name1, flag, table1) {
      var i, j;
      this.name = name1;
      this.flag = flag;
      this.table = table1;
      this.field = [];
      for (i = j = 0; j <= 2; i = ++j) {
        this.field.push(new Grid(this.flag, i, this, this.table));
      }
      this.playerHandler = new BuffHandler();
      this.playerHandler.setPlayerAndTable(this, this.table);
    }

    Player.prototype.setList = function(list1) {
      var j, len, ref, results, t;
      this.list = list1;
      this.handList = this.list.slice(0);
      this.callList = [];
      ref = this.list;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        t = ref[j];
        results.push(t.setPlayerAndTable(this, this.table));
      }
      return results;
    };

    Player.prototype.createACard = function(id, isHand, index) {
      if (isHand == null) {
        isHand = true;
      }
      if (index == null) {
        index = -1;
      }
    };

    return Player;

  })();


  /**
   * cmds: array, to log actions
   * defenser: player
   * attacker: player, to be enemy with each other
   * battle: array[2][3], to hold grids
   * list: array, to hold all pokemon
   * callList: array, which in battle, use when [actSequence]
   * actionList: array, used in [actSequence] in a turn
   * weatherHandler: CardMode, to handle weather buffs
   */

  Table = (function() {
    function Table(attackerList, defenserList) {
      var table;
      table = this;
      this.init(attackerList, defenserList);
      this.cmds = [];
      this.em = new EventManager();
      this.em.setcbs({
        whenTurnStart: function(turnCount) {
          return table.cmds.push(['whenTurnStart', turnCount]);
        },
        whenCall: function(card, driver, row, col) {
          var grid, player;
          table.cmds.push(['whenCall', card, driver, row, col]);
          console.log('when call: ' + card.name);
          player = (driver instanceof Player ? driver : driver.player);
          grid = table.battle[row][col];
          card = player.handList.shift();
          grid.setPokemon(card);
          return table.callList.push(card);
        },
        whenRegain: function(card, driver, row, col) {
          var grid, player;
          table.cmds.push(['whenRegain', card, driver, row, col]);
          console.log('when regain: ' + card.name);
          grid = table.battle[row][col];
          grid.removePokemon();
          player = (driver instanceof Player ? driver : driver.player);
          player.handList.push(card);
          return table.callList["delete"](card);
        },
        whenAddBuff: function(buff, toCard, driver) {
          table.cmds.push(['whenAddBuff', buff, toCard, driver]);
          return toCard.addBuff(buff);
        }
      });
    }

    Table.prototype.init = function(attackerList, defenserList) {
      this.defenser = new Player('npc', 0, this);
      this.attacker = new Player('me', 1, this);
      this.defenser.enemy = this.attacker;
      this.attacker.enemy = this.defenser;
      this.attacker.setList(attackerList);
      this.defenser.setList(defenserList);
      this.battle = [this.defenser.field, this.attacker.field];
      this.list = this.defenser.list.concat(this.attacker.list);
      this.callList = [];
      this.actionList = [];
      this.weatherHandler = new BuffHandler();
      return this.weatherHandler.setPlayerAndTable(null, this);
    };

    Table.prototype.turnUpdate = function(n) {
      var j, len, len1, len2, len3, m, q, ref, ref1, ref2, removeList, s, t;
      removeList = [];
      this.weatherHandler.turnUpdate(n);
      this.attacker.playerHandler.turnUpdate(n);
      this.defenser.playerHandler.turnUpdate(n);
      ref = this.defenser.field;
      for (j = 0, len = ref.length; j < len; j++) {
        t = ref[j];
        t.gridHandler.turnUpdate(n);
      }
      ref1 = this.attacker.field;
      for (m = 0, len1 = ref1.length; m < len1; m++) {
        t = ref1[m];
        t.gridHandler.turnUpdate(n);
      }
      ref2 = this.list;
      for (q = 0, len2 = ref2.length; q < len2; q++) {
        t = ref2[q];
        t.turnUpdate(n);
        if (t.hp <= 0) {
          removeList.push(t);
        }
      }
      if (removeList.length > 0) {
        for (s = 0, len3 = removeList.length; s < len3; s++) {
          t = removeList[s];
          t.die();
        }
        return this.list = (function() {
          var len4, ref3, results, u;
          ref3 = this.list;
          results = [];
          for (u = 0, len4 = ref3.length; u < len4; u++) {
            t = ref3[u];
            if (t.hp > 0) {
              results.push(t);
            }
          }
          return results;
        }).call(this);
      }
    };

    Table.prototype.call = function(who, to) {
      var grid, p, player;
      if (!((who === 0 || who === 1) && (to === 0 || to === 1 || to === 2))) {
        throw "[Table] call out of bound: who[" + who + "], to[" + to + "]";
      }
      player = (who === 0 ? this.defenser : this.attacker);
      grid = this.battle[who][to];
      p = player.handList[0];
      if (p == null) {
        return;
      }
      if (grid.pokemon != null) {
        this.regain(who, to);
      }
      this.em.broadcast('whenCall', p, player, who, to);
      return p;
    };

    Table.prototype.regain = function(who, to) {
      var grid, p, player;
      if (!((who === 0 || who === 1) && (to === 0 || to === 1 || to === 2))) {
        throw "[Table] regain out of bound: who[" + who + "], to[" + to + "]";
      }
      player = (who === 0 ? this.defenser : this.attacker);
      grid = this.battle[who][to];
      p = grid.pokemon;
      if (p == null) {
        return;
      }
      this.em.broadcast('whenRegain', p, player, who, to);
      return p;
    };

    Table.prototype.createInBattle = function(p, row, col) {};

    Table.prototype.get = function(row, col) {
      return this.battle[row][col].pokemon;
    };

    Table.prototype.removeFromBattle = function(row, col) {
      var p;
      p = this.battle[row][col].pokemon;
      this.battle[row][col] = null;
      this.callList["delete"](p);
      return p;
    };

    Table.prototype.isEmpty = function(row, col) {
      if (this.battle[row][col].pokemon === null) {
        return true;
      } else {
        return false;
      }
    };

    Table.prototype.actSequence = function() {
      var p, results;
      this.actionList = this.callList.slice(0);
      results = [];
      while (this.actionList.length > 0) {
        p = this.getFirstAction();
        p.act();
        results.push(console.log('actSequence : ' + p.spd));
      }
      return results;
    };

    Table.prototype.getFirstAction = function() {
      var sortBySpd;
      sortBySpd = function(a, b) {
        return -1 * (a.spd + a.spdLevel - b.spd - b.spdLevel);
      };
      this.actionList.sort(sortBySpd);
      return this.actionList.shift();
    };

    Table.prototype.next = function(n) {
      var t;
      this.cmds = [];
      this.call(1, n);
      t = random(3);
      this.call(0, t);
      this.em.broadcast('whenTurnStart', 0);
      this.actSequence();
      return this.em.broadcast('whenTurnEnd', 0);
    };

    return Table;

  })();

  a = [];

  for (i = j = 0; j < 6; i = ++j) {
    a.push(CardMode.testCard());
  }

  b = [];

  for (i = m = 0; m < 6; i = ++m) {
    b.push(CardMode.testCard());
  }

  table = new Table(a, b);

  skill = {
    whenCallAfter: function(card, driver, x, y) {
      var em;
      console.log('skill catch: ' + card.spd);
      table = card.table;
      em = card.table.em;
      if (y === 1) {
        table.cmds.push(['showSkill', 'owner', 'skill']);
        return em.broadcast('whenRegain', card, driver, x, y);
      }
    }
  };

  table.em.listen(skill, 'whenCallAfter');

  table.call(1, 1).spd = 1;

  t = table.call(1, 2);

  t.spd = 100;

  t.spdLevel = -6;

  table.actSequence();

  table.regain(1, 1);

  console.log(table.cmds);

  root = typeof exports !== "undefined" && exports !== null ? exports : window;

  root.Trigger = Trigger;

  root.EventManager = EventManager;

  root.Buff = Buff;

  root.CardMode = CardMode;

  root.Table = Table;

}).call(this);

//# sourceMappingURL=trigger.js.map
