// Generated by CoffeeScript 1.9.2
(function() {
  var NodeOperateChain, Player, gs, root,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Player = (function() {
    function Player(id1, name) {
      this.id = id1;
      this.name = name;
    }

    return Player;

  })();

  NodeOperateChain = (function() {
    function NodeOperateChain(node) {
      this.node = node;
      this.prev = [];
      this.prev.push(this.node);
    }


    /*
    	#
       #@cb {Function} click callback function
     */

    NodeOperateChain.prototype.click = function(cb) {
      var eventListener, that;
      that = this;
      if (cb == null) {
        throw "callback is not defined";
      }
      eventListener = cc.EventListener.create({
        event: cc.EventListener.TOUCH_ONE_BY_ONE,
        swallowTouches: true,
        onTouchBegan: function(event) {
          var loc, rect;
          loc = event.getLocation();
          rect = that.node.getBoundingBox();
          if (cc.rectContainsPoint(rect, loc)) {
            cb.call(that.node, event);
            return true;
          } else {
            return false;
          }
        }
      });
      cc.eventManager.addListener(eventListener, this.node);
      return this;
    };

    NodeOperateChain.prototype.bindTimer = function(isParticle) {
      var t;
      if (isParticle == null) {
        isParticle = false;
      }
      t = gs.battleLayer;
      if (t == null) {
        throw "the battle Layer does not been created";
      }
      this.node._scheduler = t._scheduler;
      this.node._actionManager = t._actionManager;
      if (isParticle) {
        this.node.scheduleUpdate();
      }
      return this;
    };

    return NodeOperateChain;

  })();

  gs = function(select) {
    if (select instanceof cc.Node) {
      return new NodeOperateChain(select);
    }
  };

  gs.init = function() {
    this.preLoadArray = [];
    this.uids = {};
    this.uidCount = 0;
    this.trigger = {};
    this.enemyArray = [];
    this.playerArray = [];
    this.battleArray = [];
    this.battleLayer = null;
    return this.size = cc.winSize;
  };

  gs.start = function(levelData, playerData) {
    this.levelData = levelData;
    this.playerData = playerData;
    return this.init();
  };

  gs.getPicture = function(id) {
    if (typeof id === 'string') {
      id = Number(id);
    }
    if (id < 1000) {
      id = (id + 1000).toString().slice(1);
    } else {
      id = (id + 10000).toString().slice(1);
    }
    return 'res/pokemons/image' + id + '.png';
  };

  gs.getPreLoad = function() {
    var c, r1, r2;
    r1 = (function() {
      var k, len, ref, ref1, results;
      ref = this.enemyArray;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        c = ref[k];
        results.push(gs.getPicture(c != null ? (ref1 = c.pd) != null ? ref1.id : void 0 : void 0));
      }
      return results;
    }).call(this);
    r2 = (function() {
      var k, len, ref, ref1, results;
      ref = this.playerArray;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        c = ref[k];
        results.push(gs.getPicture(c != null ? (ref1 = c.pd) != null ? ref1.id : void 0 : void 0));
      }
      return results;
    }).call(this);
    return slice.call(r1).concat(slice.call(r2));
  };

  gs.registerCard = function(card) {
    this.uids[this.uidCount++] = card;
    return card.uid = this.uidCount;
  };

  gs.listen = function(waiter, eventName) {
    if (this.trigger[eventName] == null) {
      this.trigger[eventName] = [];
    }
    return this.trigger[eventName].push(waiter);
  };

  gs.disListen = function(waiter, eventName) {
    var card;
    if (this.trigger[eventName] != null) {
      return this.trigger[eventName] = (function() {
        var k, len, ref, results;
        ref = this.trigger[eventName];
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          card = ref[k];
          if (card !== waiter) {
            results.push(card);
          }
        }
        return results;
      }).call(this);
    }
  };

  gs.broadCast = function() {
    var args, eventName, k, len, ref, waiter;
    eventName = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (this.trigger[eventName] == null) {
      return false;
    }
    ref = this.trigger[eventName];
    for (k = 0, len = ref.length; k < len; k++) {
      waiter = ref[k];
      if (waiter.isSilence) {
        continue;
      }
      waitter[eventName].apply(waitter, args);
    }
    return true;
  };

  gs.random = function(n) {
    return Math.floor(Math.random() * n);
  };

  gs.remove = function(list, n) {
    var t;
    t = list[n];
    list.splice(n, 1);
    return t;
  };

  gs.spliteFrame = function(str, row, col) {
    var frames, h, height, i, j, k, l, ref, ref1, ref2, temp, texture, w, width;
    texture = cc.textureCache.addImage(str);
    ref = texture.getContentSize(), width = ref.width, height = ref.height;
    w = width / col | 0;
    h = height / row | 0;
    frames = [];
    for (i = k = 0, ref1 = row; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
      temp = [];
      for (j = l = 0, ref2 = col; 0 <= ref2 ? l < ref2 : l > ref2; j = 0 <= ref2 ? ++l : --l) {
        temp.push(new cc.SpriteFrame(texture, cc.rect(j * w, i * h, w, h)));
      }
      frames.push(temp);
    }
    return frames;
  };

  gs.getNearest = function(p, n) {
    var arr, t, x, y;
    x = p.x, y = p.y;
    arr = (function() {
      var k, len, ref, results;
      ref = gs.battleArray;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        t = ref[k];
        if (t !== p) {
          results.push(t);
        }
      }
      return results;
    })();
    arr.sort(function(p1, p2) {
      if ((Math.pow(p1.x - x, 2) + Math.pow(p1.y - y, 2)) < (Math.pow(p2.x - x, 2) + Math.pow(p2.y - y, 2))) {
        return -1;
      } else {
        return 1;
      }
    });
    if ((n != null) > 1) {
      return arr.slice(0, n);
    } else {
      return arr[0];
    }
  };

  gs.getNearestGrid = function(p) {
    var arr, temp, x, y;
    x = p.x, y = p.y;
    arr = gs.uLoc.concat(gs.dLoc);
    arr.sort(function(p1, p2) {
      if ((Math.pow(p1.x - x, 2) + Math.pow(p1.y - y, 2)) < (Math.pow(p2.x - x, 2) + Math.pow(p2.y - y, 2))) {
        return -1;
      } else {
        return 1;
      }
    });
    temp = arr[0];
    y = (indexOf.call(gs.uLoc, temp) >= 0 ? 0 : 1);
    x = (y === 0 ? gs.uLoc.indexOf(temp) : gs.dLoc.indexOf(temp));
    return {
      x: x,
      y: y
    };
  };

  gs.init();

  root = typeof exports !== "undefined" && exports !== null ? exports : window;

  root.gs = gs;

}).call(this);

//# sourceMappingURL=gameRuntimeData.js.map
